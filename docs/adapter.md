# 编写社区适配器

使用 `engine/dataHandler.ts@defineAdapter` 函数来提供编写适配器时的类型提示。

## 社区名称

在配置对象的 `communityName` 字段写当前适配器适配的社区的中文名，最好是**人类可读**的。

## 获取用户数据

配置对象的 `getInfo` 方法写向**社区API发送请求**的过程，接收一个参数代表用户调用时传入的对应**社区用户名**。

## 字段

在配置对象的 `fields` 字段写一个对象，其下有 `username` 和 `rank` 两个字段。

### 从查询字符串读取社区用户名

`username` 这个字段代表url查询字符串的键，对应的值会被传入给 `getInfo` 方法的 *参数0*，很显然这个键对应的值必须传入社区的**用户ID**而**不是昵称**。

### 分级系统

`rank` 下面还有两个键 `system` 和 `store`，`system` 写分级系统的**引用名称**，`store`写分级系统的**具体数值**，这个 `store` 我提供了很多写法。

#### 标签对应上限，但是数组形式

写一个数组，实现接口 **{label:RankLevel,max:number}[]**，`label` 对应分级的标签（A~S），`max` 对应这个标签的最大分数，这个数组会按照 `max` 字段的值进行从小到大的排序。

#### 标签对应上限

写一个字典，实现接口 **Record<RankLevel,number>**，键对应分级的标签（A~S），值对应这个标签的最大分数，这种格式的分级系统会被自动标准化为上文的数组格式。

#### 按最高分平均分配

这个字段只需要填一个数字，代表该分级系统下S分级的分数上限，如果某个用户的分数超过了这个上限，就会分为**S+级**，低于时就将分数平均分配到**A~S**，这种格式的分级系统会被自动标准化为上文的字典格式。

感觉不如 **~~Anti-Anti-Anti-Anti-CSense~~**
